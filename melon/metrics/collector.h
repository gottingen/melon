
#ifndef MELON_VARIABLE_COLLECTOR_H_
#define MELON_VARIABLE_COLLECTOR_H_

#include "melon/container/linked_list.h"
#include "melon/base/fast_rand.h"
#include "melon/times/time.h"
#include "melon/base/static_atomic.h"
#include "melon/metrics/gauge.h"

namespace melon {

    // Containing the context for limiting sampling speed.
    struct CollectorSpeedLimit {
        // [Managed by Collector, don't change!]
        size_t sampling_range;
        bool ever_grabbed;
        melon::static_atomic<int> count_before_grabbed;
        int64_t first_sample_real_us;
    };

    static const size_t COLLECTOR_SAMPLING_BASE = 16384;

#define VARIABLE_COLLECTOR_SPEED_LIMIT_INITIALIZER                          \
    { ::melon::COLLECTOR_SAMPLING_BASE, false, MELON_STATIC_ATOMIC_INIT(0), 0 }

    class Collected;

// For processing samples in batch before dumping.
    class CollectorPreprocessor {
    public:
        virtual void process(std::vector<Collected *> &samples) = 0;
    };

    // Steps for sampling and dumping sth:
    //  1. Implement Collected
    //  2. Create an instance and fill in data.
    //  3. submit() the instance.
    class Collected : public melon::container::link_node<Collected> {
    public:
        virtual ~Collected() {}

        // Sumbit the sample for later dumping, a sample can only be submitted once.
        // submit() is implemented as writing a value to melon::variable_reducer which does
        // not compete globally. This function generally does not alter the
        // interleaving status of threads even in highly contended situations.
        // You should also create the sample using a malloc() impl. that are
        // unlikely to contend, keeping interruptions minimal.
        // `cpuwide_us' should be got from melon::get_current_time_micros(). If it's far
        // from the timestamp updated by collecting thread(which basically means
        // the thread is not scheduled by OS in time), this sample is directly
        // destroy()-ed to avoid memory explosion.
        void submit(int64_t cpuwide_us);

        void submit() { submit(melon::get_current_time_micros()); }

        // Implement this method to dump the sample into files and destroy it.
        // This method is called in a separate thread and can be blocked
        // indefinitely long(not recommended). If too many samples wait for
        // this funcion due to previous sample's blocking, they'll be destroy()-ed.
        // If you need to run destruction code upon thread's exit, use
        // melon::thread::atexit. Dumping thread run this function in batch, each
        // batch is counted as one "round", `round_index' is the round that
        // dumping thread is currently at, counting from 1.
        virtual void dump_and_destroy(size_t round_index) = 0;

        // Destroy the sample. Will be called for at most once. Since dumping
        // thread generally quits upon the termination of program, some samples
        // are directly recycled along with program w/o calling destroy().
        virtual void destroy() = 0;

        // Returns an object to control #samples collected per second.
        // If nullptr is returned, samples collected per second is limited by a
        // global speed limit shared with other samples also returning nullptr.
        // All instances of a subclass of Collected should return a same instance
        // of CollectorSpeedLimit. The instance should remain valid during lifetime
        // of program.
        virtual CollectorSpeedLimit *speed_limit() = 0;

        // If this method returns a non-nullptr instance, it will be applied to
        // samples in batch before dumping. You can sort or shuffle the samples
        // in the impl.
        // All instances of a subclass of Collected should return a same instance
        // of CollectorPreprocessor. The instance should remain valid during
        // lifetime of program.
        virtual CollectorPreprocessor *preprocessor() { return nullptr; }
    };

    // To know if an instance should be sampled.
    // Returns a positive number when the object should be sampled, 0 otherwise.
    // The number is approximately the current probability of sampling times
    // COLLECTOR_SAMPLING_BASE, it varies from seconds to seconds being adjusted
    // by collecting thread to control the samples collected per second.
    // This function should cost less than 10ns in most cases.
    inline size_t is_collectable(CollectorSpeedLimit *speed_limit) {
        if (speed_limit->ever_grabbed) { // most common case
            const size_t sampling_range = speed_limit->sampling_range;
            // fast_rand is faster than fast_rand_in
            if ((melon::base::fast_rand() & (COLLECTOR_SAMPLING_BASE - 1)) >= sampling_range) {
                return 0;
            }
            return sampling_range;
        }
        // Slower, only runs before -variable_collector_expected_per_second samples are
        // collected to calculate a more reasonable sampling_range for the type.
        extern size_t is_collectable_before_first_time_grabbed(CollectorSpeedLimit *);
        return is_collectable_before_first_time_grabbed(speed_limit);
    }

    // An utility for displaying current sampling ratio according to speed limit.
    class DisplaySamplingRatio {
    public:
        DisplaySamplingRatio(const char *name, const CollectorSpeedLimit *);

    private:
        melon::status_gauge<double> _var;
    };

}  // namespace melon

#endif  // MELON_VARIABLE_COLLECTOR_H_
